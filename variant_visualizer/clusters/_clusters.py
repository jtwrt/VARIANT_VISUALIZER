from .. import genome_annotation as ga
from .. import variants, cre, core
from .._config import config
import os, yaml, warnings
from ..setup._setup_utils import dill_dump_object, dill_load_object, block_print, enable_print
from copy import deepcopy

class ClusterGenerator():
    """
    Description
    ---
    
    Generates Cluster instances.
    Retrieves all genomic features, CRE and variants located in the cluster
    and uses them to initialize Cluster instances, which will then be saved
    as binary file for later use.

    Parameters
    ---

    n_threads : int
    number of threads available for multiprocessing
    
    gtf_cluster_ids : list / 'all'
    list of integers (gtf_cluster_ids in GTF) or 'all' to calculate 
    for each cluster of the GTF

    run_id : None / int
    

    predict_rbp_binding_in : str
    'UTR' to predict RBP-binding sites in 5' and 3' UTR,
    'UTR+Regulatory_Sequence' to also predict rbp-binding sites in
    the regulatory regions flanking the UTR as specified in the 
    config.yml
    """
    def __init__(self, process_number: int, n_processes: int, selected_clusters='all'):

        os.makedirs(os.path.join(config['general']['data_dir'], 'clusters'), exist_ok=True)              
        os.makedirs(os.path.join(config['general']['tmp_dir'], 'cluster_inputs'), exist_ok=True)   

        #print('Loading Gtf ...')
        self.clustered_gtf = ga.load_gtf(clustered=True)
        all_gtf_cluster_ids = set(self.clustered_gtf['cluster'])
        if selected_clusters == 'all':
            selected_clusters = all_gtf_cluster_ids
        else:
            selected_clusters = [i for i in selected_clusters if i in all_gtf_cluster_ids]
      
        # select clusters which will be generated by this process
        process_cluster_ids = []
        k = 0
        for i, cluster_id in enumerate(selected_clusters):
            if i == k*n_processes + process_number:
                process_cluster_ids.append(cluster_id)
                k += 1

        #print('Generating GTF slices ...')
        step_cluster_ids = [i for i in process_cluster_ids if 
                            not os.path.isfile(ga.get_gtf_slice_path(i))]
        for cluster_id in step_cluster_ids:
            self.slice_gtf(cluster_id)
        del self.clustered_gtf

        self.mc3 = variants.load_mc3()
        
        # 'Create GtfCluster instances and associated Variants lists ...'
        step_cluster_ids = [i for i in process_cluster_ids if 
                                not os.path.isfile(self.get_gtf_cluster_path(i)) or
                                not os.path.isfile(self.get_variants_path(i))]
        cluster_info = []
        for cluster_id in step_cluster_ids:
            cluster_info.append(self.make_gtf_clusters_and_variants(cluster_id))    
        del self.mc3

        self._targetscan_db = cre.mirna_binding.load_targetscan_db()
        self._pas_atlas_db = cre.pas.load_pas_atlas_db()
        self._smeagol_genome = cre.rbp_binding.load_smeagol_genome()
        self._smeagol_pwms = cre.rbp_binding.load_smeagol_pwms()
    
        predict_rbp_binding_in = config['smeagol']['predict_rbp_binding_in']
        if not isinstance(predict_rbp_binding_in, str):
            raise TypeError
        if predict_rbp_binding_in == 'UTR':
            self._rbp_binding_feature_types = ['three_prime_utr',
                                              'five_prime_utr',
                                              'five_and_three_prime_utr']
        elif predict_rbp_binding_in == 'UTR+Regulatory_Sequence':
            self._rbp_binding_feature_types = ['three_prime_utr',
                                              'five_prime_utr',
                                              'five_and_three_prime_utr',
                                              'three_prime_regulatory_sequence',
                                              'five_prime_regulatory_sequence',
                                              'five_and_three_prime_regulatory_sequence']
        else:
            raise ValueError

        # Creating Cluster objects ...
        for cluster_id in process_cluster_ids:
            self.make_cluster(cluster_id)
        
    def get_gtf_cluster_path(self, cluster_id: int) -> str:
        return os.path.join(config['general']['tmp_dir'], f'cluster_inputs/gtf_cluster_cid{cluster_id}.dill')

    def get_variants_path(self, cluster_id: int) -> str:
        return os.path.join(config['general']['tmp_dir'], f'cluster_inputs/variants_cid{cluster_id}.dill')

    def slice_gtf(self, cluster_id: int):
        """Ready for multiprocessing"""
        ga.slice_clustered_gtf(cluster_id, self.clustered_gtf)
        return

    def make_gtf_clusters_and_variants(self, cluster_id: int):
        """Ready for multiprocessing, returns cluster_id, index_input as tuple."""
        gtf_slice = ga.load_gtf_clustered_slice(cluster_id)
        gtf_cluster = ga.GtfCluster(cluster_id, gtf_slice)
        dill_dump_object(self.get_gtf_cluster_path(cluster_id), gtf_cluster)
        if not os.path.isfile(self.get_variants_path(cluster_id)):
            mutations = variants.get_mc3_variants(variants.get_region_slice(gtf_cluster, self.mc3))
            dill_dump_object(self.get_variants_path(cluster_id), mutations)
        return

    def make_cluster(self, cluster_id: int):
        """Ready for multiprocessing"""
        gtf_cluster = dill_load_object(self.get_gtf_cluster_path(cluster_id))
        mutations = dill_load_object(self.get_variants_path(cluster_id))
        cre_dict = dict()
        cre_dict['PAS'] = cre.pas.get_pas_atlas_pas(
            gtf_cluster, self._pas_atlas_db)
        cre_dict['MiRNABinding'] = cre.mirna_binding.get_targetscan_mirna_binding(
            gtf_cluster, self._targetscan_db)
        cre_dict['RBPBinding'] = []

        block_print()
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            # ignore tensorflow retracing warnings. 
            # Retracing makes this calculation less efficient,
            # but can not currently be avoided.
            smeagol_model = cre.rbp_binding.load_smeagol_model(self._smeagol_pwms)
            smeagol_regions = []
            for strand in ['-','+']:
                for feature_type in self._rbp_binding_feature_types:
                    smeagol_regions += gtf_cluster.cluster_segments[strand][feature_type]
            smeagol_regions = core.combine_regions(smeagol_regions)
            for r in smeagol_regions:
                cre_dict['RBPBinding'].extend(
                    cre.rbp_binding.get_smeagol_rbp_binding(
                        r, self._smeagol_pwms, smeagol_model,
                        self._smeagol_genome))

        cluster = Cluster(
            cluster_id=cluster_id,
            gtf_cluster=gtf_cluster,
            variants=mutations,
            cre_dict=cre_dict)
        dill_dump_object(_get_cluster_path(cluster_id), cluster)
        enable_print()
        return   

class Cluster():
    """
    Class that integrates information from 
    genome_annotation, cre, and variants modules.
    A instance saves variants, cis-regulatory elements and 
    genomic features that are close in genomic sequence.
    A single cluster can thus be used for visualization
    and get the full picture of a genomic region.

    Supposed to only be internally called by ClusterGenerator 
    and when loading a Cluster from file. In the latter case,
    A new instance is created, and data attributes are transfered.
    This is to be able to patch methods without having to recalculate
    the data, if not required.
    """

    def __init__(self, cluster_id=None|int, gtf_cluster=None|ga.GtfCluster, variants=None|list, cre_dict=None|dict, _cluster=None) -> None:
        
        if _cluster is None:
            self.cluster_id = cluster_id
            self.gtf_cluster = gtf_cluster
            self.cre = cre_dict
            self.variants = variants
        else:
            self.cluster_id = _cluster.cluster_id
            self.gtf_cluster = _cluster.gtf_cluster
            self.cre = _cluster.cre
            self.variants = _cluster.variants

    def get_reference(self, gene_id=None, transcript_id=None, reference_type='default'):
        """
        Return a BioReference from this cluster. By default, 
        returns a general GenomicReference matching features in this cluster.
        If transcript_id is a valid ensembl_id, returns the TranscriptReference.
        If gene_id is a valid ensembl_id, returns the matching GenomicRefernce
        for the gene.

        If reference_type is either genomic/transcript/protein, 
        tries to convert the default value to the requested reference type.
        """
        out = None
        if transcript_id is None and gene_id is None:
            out =  self.gtf_cluster.reference
        elif transcript_id is None and gene_id is not None:
            for r in self.gtf_cluster.all_regions:
                if r.gene_id == gene_id:
                    out =  r.reference
                    break
        elif transcript_id is not None and gene_id is None:
            for r in self.gtf_cluster.all_regions:
                if r.transcript_id == transcript_id:
                    out = r.reference.convert_reference_type('transcript')
                    break
        elif transcript_id is not None and gene_id is not None:
            for r in self.gtf_cluster.all_regions:
                if r.transcript_id == transcript_id and \
                        r.gene_id == gene_id:
                    out = r.reference
        if out is None:
            raise ValueError('Transript or gene is not part of cluster.')

        if reference_type == 'default':
            return out
        else:
            return out.convert_reference_type(
                reference_type
            )

    def get_gtf_cluster(self):
        """Return the associated GtfCluser object"""
        return deepcopy(self.gtf_cluster)
    
    def _get_filter_regions(self, gene_ids='all', transcript_ids='all'):
        """Return gtf features with matching gene_ids and transcript_ids"""

        out = self.gtf_cluster.all_regions
        if gene_ids == 'all' and transcript_ids == 'all':
            return out
        
        if gene_ids != 'all':
            if not all([isinstance(e, str) and e[0:4]=='ENSG' for e in gene_ids]):
                raise ValueError
            out = [r for r in out if r.gene_id in gene_ids]
        if transcript_ids != 'all':
            if not all([isinstance(e, str) and e[0:4]=='ENST' for e in transcript_ids]):
                raise ValueError
            out = [r for r in out if r.transcript_id in transcript_ids]
        return out

    def get_variants(self, gene_ids='all', transcript_ids='all'):
        """
        Return variants that overlap the given genes or transcripts. 
        Provide list or set of ensembl_ids to filter variants. 
        Returns all cluster variants by default.
        """
        out = deepcopy(self.variants)
        if gene_ids == 'all' and transcript_ids == 'all':
            return out

        filter_regions = self._get_filter_regions(
            gene_ids=gene_ids,
            transcript_ids=transcript_ids
        )
        return [r for r in out if 
                any([r.overlaps(f) for f in filter_regions])]       
    
    def get_cis_regulatory_elements(self, gene_ids='all', transcript_ids='all'):
        """
        Return cis-regulatory elements of this cluster, which overlap the given genes or transcripts.
        Provide list or set of ensembl_ids to filter returned regions.
        """

        if gene_ids == 'all' and transcript_ids == 'all':
            return deepcopy(self.cre)

        filter_regions = self._get_filter_regions(
            gene_ids=gene_ids,
            transcript_ids=transcript_ids
        )
        strands = set([r.reference.strand for r in filter_regions])
        out = dict()
        for key in self.cre:
            this_cre = deepcopy(self.cre[key])
            out[key] = [r for r in this_cre if 
                        any([r.overlaps(f) for f in filter_regions]) and
                        r.reference.strand in strands]
        return out

    def get_pas(self, gene_ids='all', transcript_ids='all'):
        cis_reg_elements = self.get_cis_regulatory_elements(
            gene_ids=gene_ids,
            transcript_ids=transcript_ids
        )
        return cis_reg_elements['PAS']
    
    def get_miRNA_binding(self, gene_ids='all', transcript_ids='all'):
        cis_reg_elements =  self.get_cis_regulatory_elements(
            gene_ids=gene_ids,
            transcript_ids=transcript_ids
        )
        return cis_reg_elements['MiRNABinding']

    def get_rbp_binding(self, gene_ids='all', transcript_ids='all'):
        cis_reg_elements = self.get_cis_regulatory_elements(
            gene_ids=gene_ids,
            transcript_ids=transcript_ids
        )
        return cis_reg_elements['RBPBinding']

def _get_cluster_path(cluster_id: int) -> str:
    return os.path.join(config['general']['data_dir'], f'clusters/cluster_{cluster_id}.dill')

def load_cluster(cluster_id: int) -> Cluster:
    stored = dill_load_object(_get_cluster_path(cluster_id))
    out = Cluster(_cluster=stored)
    return out 

